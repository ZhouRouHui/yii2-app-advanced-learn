主要以高级模板为基础的学习笔记https://www.bilibili.com/video/BV1NE411T7EW?spm_id_from=pageDriverhttp://www.weixistyle.com/yii2.php安装和启动    安装分两种，基础模板和高级模板    - 基础模板        composer create-project --prefer-dist yiisoft/yii2-app-basic basic    - 高级模板        - composer create-project --prefer-dist yiisoft/yii2-app-advanced advanced        - 执行 init 文件或 init.bat 文件            - mac 或 linux 系统通过 php 执行 init 文件，也就是 `php init`            - windows 系统直接双击执行 init.bat 文件            命令行会提示配置当前环境，然后生成几个文件，这几个文件默认都是 git 忽略的        - 创建数据库，并在 common/config/main-local.php 中配置数据库链接        - 执行 `php yii migrate` 数据迁移，migration 文件在 console/migrations 目录中欢迎界面显示    http://yii2.me    http://yii2.me/index.php    http://yii2.me/index.php?r=site/index路径别名    在 common/config/bootstrap.php 中设置了很多别名，设置好的别名在别的配置文件中可以直接使用获取一个请求的 request 对象    $request = \Yii::$app->request;    request 对象的操作    $id = $request->get('id', 1000);    // get 请求的参数，参数二为默认值    $name = $request->post('name', 'roy');  // post 请求的参数，参数二为默认值    $request->method;   // 获取请求方式，get，post，put...    $request->isGet;    // 判断是否是 get 请求    $request->isPost;   // 判断是否是 post 请求    $request->userIp;   // 获取用户 IP脚手架 GII 的使用，gii 是 yii 框架的脚手架工具，快速生成代码文件    1. 在 backend/config/main-local.php 或 frontend/config/main-local.php 中开启 gii 模块    2. 然后访问前台或者后台对应的页面，注意 r=gii 的参数，例如：        http://localhost/yii2-app-advanced/backend/web/index.php?r=gii    Model Generator 生成模型文件    CRUD Generator 生成控制器，视图等文件查询构建器 QueryBuilder，这种方式查询得到的结果不会是模型对象，只会是单个值或者是数组    - 常用查询方法        - all() 返回一个由行组成的数组，每一行是一个由名称和值构成的关联数组        - one() 返回结果集的第一行        - column() 返回结果集的第一列        - scalar() 返回结果集的第一行第一列的标量值        - exists() 返回一个表示该查询是否包含结果集的值        - count() 返回 count 的结果        - sum() 返回列的和值        - average() 返回列的平均值        - max() 返回列的最大值        - min() 返回列的最小值    例子：    $rows = (new \yii\db\Query())        ->select(['id', 'email'])        ->from('user')        ->where(['last_name' => ':last_name'])        ->addParams([':status' => 'Smith'])        ->orderBy('id')        ->limit(10)        ->indexBy('id')        ->all();    - select() 使用字符串或一个数组指定要查询的字段        - 如果不写 select() 方法，默认就是 select *        - select('id, email')        - select(['id', 'email'])        - select('user.id as user_id, email')        - select(["concat(first_name, ' ', last_name) as full_name, 'email'"])        - 子查询，例如：            - 构建一个 "select id, (select count(*) from user) as count from post"            - $subQuery = (new \yii\db\Query())->select('count(*)')->from('user');            - $query = (new \yii\db\Query())->select(['id', 'count' => $subQuery])->from('post');        - 调用 yii\db\Query::addSelect() 方法来附加字段，例如：            - $query->select(['id', 'username'])->addSelect(['email']);    - from() 指定 sql 语句当中查询的表        - from('user')        - from 中的表名可包含数据库前缀以及表别名，例如：            - from(['public.user u', 'public.post p'])            - from('public.user u, public.post p')        - 子查询的结果当做表，例如：            - 构建一个 "select * from (select id from user where status = 1) u"            - $subQuery = (new \yii\db\Query())->select('id')->from('user')->where('status = 1');            - $query->from(['u' => $subQuery]);    - where() 查询条件        - where('status=1') 字符串格式        - where(['status' => 1, 'type' => 2]) 键值对数组格式        - where(['like', 'name', 'test']) 操作符格式    - addParams() 给 where 语句中的占位符绑定参数    - orderBy() 排序        - orderBy('id asc, name desc')        - orderBy(['id' => SORT_ASC, 'name' => SORT_DESC])    - limit() 和 offset()        - limit(10)->offset(20) 从 20 开始取 10 条数据    - groupBy() 分组        - groupBy(['id', 'status'])        - 可以调用 addGroupBy() 为 group by 子句添加额外的字段，addSelect 和 addGroupBy 这种是为了程序化构建 sql 还来的，很多时候需要在程序中判断符合某种条件才需要添加相应的 select 字段或者是 group by 字段            - groupBy(['id', 'status'])->addGroupBy('age')    - having() 分组过滤条件        - having(['status' => 1])        - 可以调用 addHaving() 或 orHaving() 为 having 语句追加额外的条件            - having(['status' => 1])->addHaving(['>', 'age', 30])    - join() 连接        - join('left join', 'post', 'post.user_id = user.id')    - union() 联合两个不同的查询，例如：        - $query1 = (new \yii\db\Query())->select('id,category_id as type, name')->from('post')->limit(10);        - $query2 = (new \yii\db\Query())->select('id, type, name')->from('user')->limit(10);        - $query1->union($query2)    - indexBy() 指定哪个字段的值作为结果集数组的键，不指定的话，默认从 0 开始网上递增，指定的话需要在 all() 方法执行执行这个方法        - indexBy('id') 将 id 的值作为结果集中元素的键模型 ActiveRecord    where 单表查询        $articles = Article::find()->where(['id' => 5])->all();         // 查 id = 5 的数据        $articles = Article::find()->where(['>', 'id', 3])->all();      // 查 id > 3 的数据        $articles = Article::find()->where(['between', 'id', 2, 5])->all();      // 查 5 >= id >= 2 的数据        $articles = Article::find()->where(['like', 'title', '总书记'])->all();      // 查 title 包含 总书记 这个内容的数据        $articles = Article::find()->where(['like', 'title', '总书记'])->one();      // 查 title 包含 总书记 这个内容的数据    快捷查询        $articles = Article::findOne(5);    // 参数对应表的主键        $articles = Article::findAll([3, 4, 5]);    // 参数对应表的主键    asArray() 对象转成数组        $articles = Article::find()->asArray()->all();    load() 块赋值，把表单中的数据一次性赋值给当前对象的属性        $model->load($this->request->post())    validate() 执行数据校验，一般在模型的 Search 类中（如 PostSearch 类）的 search 方法内就会使用        $this->validate()    给模型添加额外的属性        /**         * 重写 attributes 方法，为模型类添加属性         * @return array|string[]         */        public function attributes()        {            return array_merge(parent::attributes(), ['authorName']);        }        - 给额外的属性添加点击排序功能            $dataProvider->sort->attributes['authorName'] = [                'asc' => ['Adminuser.nickname' => SORT_ASC],                'desc' => ['Adminuser.nickname' => SORT_DESC],            ];ActiveRecord 的生命周期    在一些方法的整个生命周期中，会调用很多方法，或者触发很多事件，可以通过重写这些方法或者捕捉这些事件来调整程序的走向。    - save() 方法执行时的生命周期        - beforeValidate() 方法被执行，触发 EVENT_BEFORE_VALIDATE 事件，这个方法在数据验证之前执行，如果这个方法执行后的返回值为 false，后面的步骤就不会执行        - 执行数据验证，如不通过，后面的步骤被略过        - afterValidate() 方法被执行，触发 EVENT_AFTER_VALIDATE 事件        - beforeSave() 方法被执行，触发 EVENT_BEFORE_INSERT 或 EVENT_BEFORE_UPDATE 事件        - 执行数据插入或修改        - afterSave() 方法被执行，触发 EVENT_AFTER_INSERT 或 EVENT_AFTER_UPDATE 事件    - new() 方法执行时的生命周期        - constructor        - init() 方法被执行，触发 EVENT_INIT 事件    - find() 方法执行时的生命周期        - constructor        - init() 方法被执行，触发 EVENT_INIT 事件        - afterFind() 方法被执行，触发 EVENT_AFTER_FIND 事件    - delete() 方法执行时的生命周期        - beforeDelete() 方法被执行，触发 EVENT_BEFORE_DELETE 事件        - 执行删除        - afterDelete() 方法被执行，触发 EVENT_AFTER_DELETE 事件    - refresh() 方法执行时的生命周期        - afterRefresh() 方法被执行，触发 EVENT_AFTER_REFRESH 事件数据库查询总结    查询方式                            构建方式                返回值（all，one方法）    Command 对象                          sql 语句                   数组    ActiveRecord 的 findBySql 方法         sql 语句                  对象    Query 对象                            查询构建器                  数组    ActiveRecord 的 find 方法              查询构建器                   对象数据提供者 DataProvider    - 什么是数据提供者        - 数据提供者可以获取数据，并提供给其他组件或页面使用        - 可对获取到的数据进行分页和排序        - 经常用来给数据小物件提供数据，方便用户互动地进行数据的分页与排序        - 实现了 yii\data\DataProviderInterface 接口类        示例：        $dataProvider = new ActiveDataProvider([            'query' => $query,            'pagination' => ['pageSize' => 5],            'sort' => [                'defaultOrder' => ['id' => SORT_DESC]            ]        ]);    - 根据获取数据方式的不同，DataProvider 还分为几个种类        - ActiveDataProvider：用 yii\db\Query 或者 yii\db\ActiveQuery 从数据库查询数据，并且以数组项的方式或者 ActiveRecord 实例的方式返回        - SqlDataProvider：执行一段 sql 语句并且将数据库数据作为数组返回        - ArrayDataProvider：将一个大的数组依据分页和排序设定返回一部分数据    - 数据提供者的常用方法        - getPagination()        - getSort()        - getCount()        - getTotalCount()        - getModels() 取得 DataProvider 中的数据，有可能是对象数组，或者是普通数组，这取决于是通过那种方式获取的数据模型的 Search 类，如 Post 模型的 PostSearch 类，这样的类文件主要是为给后台模型列表页面提供数据和搜索功能使用    - 属性和搜索表单对应    - 数据规则要重写，时期符合表单提交的这种验证需求    - 搜索的实现，是靠查询构建器来程序化地构建查询，然后交给数据提供者，再后续阶段去执行查询    - 排序的实现，是程序化地设置数据提供者 DataProvider 的 sort 配置来实现的Getter 和 Setter    - 属性定义的格式        - getter 方法名以 get 开头，get 后面的部分就是属性的名字（getName）        - setter 方法名以 set 开头，set 后面的部分就是属性的名字（setName）    - 属性的使用        定义好方法后，就可以向普通属性一样使用。但是本质有区别，当这种属性被读取时，对应的 getter 方法被调用，当属性被赋值时，对应的 setter 方法被调用    - 几点注意        - 要使用 getter，setter 来定义属性，类必须从 yii\base\Object 或其子类继承。这种方法不是只能用于模型类，只要是从 yii\base\Object 类继承的类都可以使用        - 如果只定义了 getter，而没有 setter 的属性时只读属性，对他赋值会抛出异常        - 这种方式定义的属性，一般多数都是只读的，一般不会持久化保存，多数是一个业务逻辑需要的计算结果视图    渲染视图        在 controller 的 action 中        $this->renderPartial();     // 部分渲染，不会输出父模板，指对本次渲染的局部内容进行输出        $this->render();            // 输出父模板的内容，将要渲染的内容嵌入父模板    布局文件 views/layouts/main.php 为默认的布局文件，为某一个页面单独定义布局文件        1. 在 views/layouts 目录中添加新的布局文件 wx.php，这个文件中必须要有一个地方存放 $content 变量。        2. 在控制器的 action 具体方法中指定 layout 即可，如果指定 layout = false，则这个页面就不使用布局文件            $this->layout = 'wx';    模板之间的相互调用        在当前模板中需要使用 about 模板内容的位置使用这样的方法 <?php echo $this->render('about'); ?>   // about 表示另一个模板文件    字符串过滤        <?= \yii\helpers\Html::encode($user->name) ?>   // 将带标签的内容作为 html 实体原样输出        <?= \yii\helpers\HtmlPurifier::process($user->name) ?>   // 直接将带标签的内容过滤掉不在显示    表单        yii\widgets\ActiveForm 类创建表单    Widget 小部件 DetailView        1. 数据小部件            Yii 提供了一套数据小部件 widgets，这些小部件可以用于显示数据。                - DetailView 小部件用于显示一条记录数据                - ListView 和 GridView 小部件能够用于显示一个拥有分页、排序和过滤功能的一个列表或者表格        2. DetailView            用来先是一条记录的详情，下面这些都是一条记录的情况：                - 一个 model 模型类对象的数据                - ActiveRecord 类的一个实例对象                - 由兼职对构成的一个关联数组        3. DetailView 的创建            - 调用 DetailView::widget 方法            - 'model' 对应的值可以是一个模型类的实例也可以是一个数组            - 'attributes' 属性决定显示模型的哪些属性以及如何格式化    自定义小部件 widget        - 小部件实在视图中使用的可重用单元，使用面向对象方式创建复杂和可配置用户界面单元        - 创建小部件            - 从 yii\base\Widget 继承类            - 重写 yii\base\Widget::init() 方法，方法中主要处理小部件属性            - 重写 yii\base\Widget::run() 方法，run 方法包含小部件生成渲染结果的代码            - 渲染结果可在 run() 方法中直接打印输出或以字符串返回        - 使用小部件            - TestWidget::widget(['foo' => $bar]);  // 在 TestWidget 中可以直接使用 public $foo，就可以使用这个属性了访问授权    授权是指验证用户是否允许做某件事的设定。Yii 框架提供两种授权的方法：    1. 存取控制过滤器 ACF        - 这是一种通过 yii\filters\AccessControl 类来实现的简单授权方法，非常适用于近需要简单的存取控制的应用        - 在控制器中 behaviors 方法中设定存取的规则。当用户请求一个动作的时候，ACF 会检查存取规则，判断该用户是否被允许执行所请求的动作。例：            /**             * {@inheritdoc}             */            public function behaviors()            {                return [                    'access' => [                        'class' => AccessControl::className(),                        // rules 指定规则，allow 指定是否允许，roles 指定适用于这条规则的用户角色，在 acf 中有两类角色，? 表示访客，@ 表示通过认证的用户                        'rules' => [                            [                                'actions' => ['login', 'error'],                                'allow' => true,                            ],                            [                                'actions' => ['logout', 'index'],                                'allow' => true,                                'roles' => ['@'],                            ],                        ],                    ],                    'verbs' => [                        'class' => VerbFilter::className(),                        'actions' => [                            'logout' => ['post'],                        ],                    ],                ];            }        -  rules 指定规则，allow 指定是否允许，roles 指定适用于这条规则的用户角色，在 acf 中有两类角色，? 表示访客，@ 表示通过认证的用户        - 其他可设置的存取规则：            - ips：浏览器的 ip 地址，可以使用通配符 *，为空则匹配所有 ip            - verbs：匹配哪些请求方式（如：GET, POST）            - matchCallback：php 回调，已确定应用该规则。例：                [                    'actions' => ['special-callback'],                    'matchCallback' => function ($rule, $action) {                        return date('d-m') === '31-10'; // 只有 10 月 31 日才能够访问这个页面                    }                ]            - denyCallback：php 回调，当规则禁止访问的时候会被调用。    2. 基于角色的存取控制 RBAC        - 建立授权数据            - 在 common/config/main.php 中的 components 中添加授权组件                'authManager' => [                    'class' => 'yii\rbac\DbManager',                ],            - DbManager 使用 4 张表存放授权数据，与个人之前使用的 rbac 表结构不同                - auth_item     // 既存放权限也存放角色，用 type 进行区分                    - name: varchar(64)                    - type: int(11)                    - description: text                    - rule_name: varchar(64)                    - data: text                    - created_at: int(11)                    - updated_at: int(11)                - auth_item_child   // 权限或角色的上下级关系                    - parent: varchar(64)                    - child: varchar(64)                - auth_assignment:  // 授权分配数据                    - item_name: varchar(64)                    - user_id: varchar(64)                    - created_at: int(11)                - auth_rule:                    - name: varchar(64)                    - data: text                    - created_at: int(11)                    - updated_at: int(11)            - 直接使用迁移命令创建这些表结构，因为这些表结构是 yii 内置 rbac 已经定义好的。                php yii migrate --migrationPath=@yii/rbac/migrations            - 通过 authManager 提供的 api 创建一个控制台命令(console/controller/RbacController.php)，来初始化授权数据            - 执行创建好的命令 php yii rbac/init        - 执行权限检查            - 代码例如：                controllers/PostController.php                public function actionCreate()                {                    if (!Yii::$app->user->can('createPost')) {                        throw new ForbiddenHttpException('对不起，无权操作');                    }                    ...                }            - yii\web\User::can() 方法是一种快捷用法，用于对当前登录的用户进行权限检查。                如果要能对任何用户进行权限检查，需要调用 yii\rbac\ManagerInterface::checkAccess() 方法来检查权限。控制台命令程序（相当于 laravel 中的 artisan 脚本）    - 控制台命令继承自 yii\console\Controller 控制器类    - 在控制器类中，定义一个或多个动作，动作与控制台子命令相对应    - 在动作方法中实现业务需求的代码    - 通过执行应用根目录的 yii 脚本执行命令        - 脚本命令后跟指定的路由：控制器ID/动作ID        - 例：php yii hello/world     // hello 表示 HelloController，world 表示这个控制器里面的 actionWorld 方法    - 命令行参数和命令行选项的区别        - ls app/       # app/ 就是参数        - ls -l app/    # -l 就是选项    - yii 的命令行文件定义也可以添加参数和选项        - 命令行参数            /**             * 带参的命令，参数可以传递多个，在命令行中的内容依次传递给命令行方法             * php yii hello/who zrh 18             * @param $name             * @param $age             * @param $arrParam             */            public function actionWho($name, $age, $arrParam)            {                echo "hello {$name}，age {$age} \r\n";                var_dump($arrParam);            }        - 命令行选项            /**             * 为命令行定义选项             * @var $rev             */            public $rev;            /**             * 重写 options 方法，给命令添加选项             * @param string $actionID             * @return string[]             */            public function options($actionID)            {                return ['rev'];            }            /**             * 重写 optionAliases 方法，给选项设置别名             * @return string[]             */            public function optionAliases()            {                return ['r' => 'rev'];            }            /**             * 使用选项的命令行测试方法             * php yii hello/option -r=1             */            public function actionOption()            {                if ($this->rev == 1) {                    echo strrev('hello world') . "\r\n";                } else {                    echo "hello world\r\n";                }            }            使用选项的命令行测试方法            注意：             不使用别名简写的方式选项需要两个 -                 php yii hello/option --rev=1             使用别名简写的方式选项只有一个 -                 php yii hello/option -r=1        - 设置定时任务，在 yii 中，定时任务的触发规则需要手动设置 crontab，不能像 laravel 中一样有一个文件直接配置URL 美化    默认的 url 格式为 http://localhost/yii2-app-advanced/frontend/web/index.php?r=post/index，    - apache 或 nginx 配置到 backend 或 frontend 的 web 目录    - 项目配置文件        - 在 backend 或 frontend 的 config/main.php 中开启 urlManage 的配置，并进行具体的配置            'urlManager' => [                // 开启 url 美化，可以去掉 index.php?r= 这一部分                'enablePrettyUrl' => true,                // 是否在 url 中显示脚本文件，也就是 index.php                'showScriptName' => false,                // 配置 url 伪静态后缀                'suffix' => '.html',                // 美化规则                'rules' => [                    '<controller:\w+>/<id:\d+>' => '<controller>/detail',                    'posts' => 'post/index',                ],            ],缓存    - 常用缓存 api        - get() 通过一个指定的 key 从缓存中取回一项数据。如果该项数据不存在与缓存中或者已经过期/失效，则返回值为 false        - set() 通过一个指定的 key 把一项数据存放到缓存中        - add() 如果缓存中未找到该 key，则将指定数据存放到缓存中        - multiGet() 指定多个 key，取回多项数据        - multiSet() 将多项数据存储到缓存中        - multiAdd() 将多项数据存储到缓存中        - exists()  返回一个值，指明某个键是否存在与缓存中        - delete()  通过一个 key，删除缓存中对应的值        - flush()   删除缓存中的所有数据    - 数据缓存        $data = Yii::$app->cache->get('postCount');        if ($data === false)        {        	$data = Post::find()->count();  sleep(5);        	Yii::$app->cache->set('postCount', $data, 600); //设置缓存60秒后过期        }        echo $data;    - 缓存依赖        缓存依赖是 yii\caching\Dependency 派生类的对象，这个对象可以设置一个缓存依赖条件，当这个条件发生变化时，缓存会被值为失效状态。        上面的代码加上缓存依赖就是这样的：        $data = Yii::$app->cache->get('postCount');        $dependency = new DbDependency(['sql'=>'select count(id) from post']);        if ($data === false)        {        	$data = Post::find()->count();  sleep(5);        	Yii::$app->cache->set('postCount',$data, 600,$dependency); //设置缓存60秒后过期        }        echo $data;        - 常用的缓存依赖            - DbDependency  如果指定的 sql 语句的查询结果发生了变化，则依赖改变            - FileDependency    如果文件的最后修改时间发生变化，则依赖改变            - ChainedDependency 如果依赖链上任何一个依赖产生变化，则依赖改变            - ExpressionDependency 如果指定的 PHP 表达式执行结果发生变化，则依赖改变            - GroupDependency   将一项缓存数据表挤到一个组名，你可以通过调用对象的 invalidate() 一次性将相同组名的缓存全部置位失效状态    - 片段缓存        指的是缓存页面内容中的某个片段        - 每个片段缓存有一个全局唯一的标记        - 缓存过期时间 duration 制定了缓存过期的秒数，是最常用的选项        - 和数据缓存一样，片段缓存的内容一样可以设置缓存依赖        - 片段缓存可以被嵌套使用，一个片段缓存可以被另一个包裹        - 使用片段缓存时，可能会遇到一大段较为静态的内容中有少许动态内容的情况。这时候可以在片段缓存中调用 yii\base\View::renderDynamic() 去插入动态内容，            如：$this->renderDynamic('return Yii::$app->user->identity->name;');        - 片段缓存使用示例：            $dependency = new DbDependency(['sql'=>'select count(id) from post']);            if ($this->beginCache('cache',['duration'=>600],['dependency'=>$dependency]))            {            	echo TagsCloudWidget::widget(['tags'=>$tags]);            	$this->endCache();            }    - 页面缓存        页面缓存指的是在服务器端缓存整个页面的内容。当页面被请求时，内容将从缓存中取出，而不是重新生成。        - 页面缓存有 yii\filters\PageCache 类提供支持，该类是一个过滤器，在控制器类中的 behaviors 方法中使用        - 用 only 指定需要缓存的页面        - 用 duration 指定页面缓存过期的秒数        - 页面缓存的内容一样可以设置缓存依赖        - 可以在使用页面缓存的同时，使用片段缓存和动态内容        - 页面缓存使用示例：            /**             * 页面缓存配置             */            'pageCache' => [                'class' => 'yii\filters\PageCache',                'only' => ['index'],    // 指定当前控制器需要缓存的页面                'duration' => 600,  // 过期时间配置                // 配置缓存内容可以根据一些参数的更改而生成新的缓存                'variations' => [                    // 接收 page 参数，根据 page 的不同值生成对应的缓存，解决分页情况下其他页面都只是用第一次缓存的内容的问题                    \Yii::$app->request->get('page'),                    // 接收 PostSearch 参数，根据 PostSearch 的不同值生成对应的缓存，解决搜索时每次得到的都是第一次搜索缓存的内容的问题                    \Yii::$app->request->get('PostSearch'),                ],                // 指定缓存依赖                'dependency' => [                    'class' => 'yii\caching\DbDependency',  // 依赖项                    'sql' => 'select count(id) from post',  // 依赖条件                ]            ]    - Http 缓存        http 缓存是利用客户端来缓存页面，节省页面的生成和传输的时间        - http 缓存通过配置 yii\filters\HttpCache 过滤器来实现        - 过滤器能为请求设置三种与缓存有关的 HTTP 头：            - yii\filters\HttpCache::lastModified            - yii\filters\HttpCache::etagSeed            - yii\filters\HttpCache::cacheControlHeader        - 用 only 指定缓存的页面        - Last-Modified 头            - Last-Modified 头使用时间戳标明页面自上次客户端缓存后是否被修改过            - 通过配置 lastModified 属性向客户端发送 Last-Modified 头。该属性的值应该为 PHP callable 类型，返回的是页面修改时的 Unix 时间戳        - ETag 头            - etag 使用一个哈希值表示页面内容，如果页面被修改过，哈希值也会随之改变，浏览器根据 etag 是否变化来决定是否应该刷新页面            - 通过配置 yii\filters\HttpCache::etagSeed 属性向客户端发送 ETag 头        - Cache-Control 头            Cache-Contro 头指定了页面的常规缓存策略。可以通过配置 yii\filters\HttpCache::cacheControlHeader 属性发送相应的投信息。        - 示例代码：            /**             * http 缓存配置，也就是 http 304 的缓存             */            'httpCache' => [                'class' => 'yii\filters\HttpCache',                'only' => ['detail'],                'lastModified' => function ($action, $params) {                    $q = new Query();                    return $q->from('post')->max('update_time');                },                'etagSeed' => function ($action, $params) {                    $post = $this->findModel(\Yii::$app->request->get('id'));                    return serialize([$post->title, $post->content]);                },                'cacheControlHeader' => 'public,max-age=600'            ]